import { Option, Opaque } from '@glimmer/util';
import { Opcodes } from './lib/opcodes';
export { Opcodes as Ops } from './lib/opcodes';
export declare type str = string;
export declare type TemplateReference = Option<SerializedBlock>;
export declare type YieldTo = number;
export declare function is<T>(variant: number): (value: any) => value is T;
export declare namespace Core {
    type Expression = Expressions.Expression;
    type Path = str[];
    type Params = Expression[];
    type Hash = Option<[str[], Expression[]]>;
    type Args = [Params, Hash];
    type EvalInfo = number[];
}
export declare namespace Expressions {
    type Path = Core.Path;
    type Params = Core.Params;
    type Hash = Core.Hash;
    type Unknown = [Opcodes.Unknown, str];
    type Get = [Opcodes.Get, number, Path];
    /**
     * Ambiguous between a self lookup (when not inside an eval) and
     * a local variable (when used inside of an eval).
     */
    type MaybeLocal = [Opcodes.MaybeLocal, Path];
    type Value = str | number | boolean | null;
    type HasBlock = [Opcodes.HasBlock, YieldTo];
    type HasBlockParams = [Opcodes.HasBlockParams, YieldTo];
    type Undefined = [Opcodes.Undefined];
    type ClientSide = [Opcodes.ClientSideExpression, any];
    type TupleExpression = Unknown | Get | MaybeLocal | Concat | HasBlock | HasBlockParams | Helper | Undefined | ClientSide;
    type Expression = TupleExpression | Value;
    interface Concat extends Array<any> {
        [0]: Opcodes.Concat;
        [1]: Params;
    }
    interface Helper extends Array<any> {
        [0]: Opcodes.Helper;
        [1]: str;
        [2]: Params;
        [3]: Hash;
    }
}
export declare type Expression = Expressions.Expression;
export declare type TupleExpression = Expressions.TupleExpression;
export declare namespace Statements {
    type Expression = Expressions.Expression;
    type Params = Core.Params;
    type Hash = Core.Hash;
    type Path = Core.Path;
    type Text = [Opcodes.Text, str];
    type Append = [Opcodes.Append, Expression, boolean];
    type Comment = [Opcodes.Comment, str];
    type Modifier = [Opcodes.Modifier, str, Params, Hash];
    type Block = [Opcodes.Block, str, Params, Hash, Option<SerializedInlineBlock>, Option<SerializedInlineBlock>];
    type Component = [Opcodes.Component, str, Attribute[], Hash, Option<SerializedInlineBlock>];
    type DynamicComponent = [Opcodes.DynamicComponent, Expression, Attribute[], Hash, Option<SerializedInlineBlock>];
    type OpenElement = [Opcodes.OpenElement, str];
    type SplatElement = [Opcodes.OpenSplattedElement, str];
    type FlushElement = [Opcodes.FlushElement];
    type CloseElement = [Opcodes.CloseElement];
    type StaticAttr = [Opcodes.StaticAttr, str, Expression, Option<str>];
    type DynamicAttr = [Opcodes.DynamicAttr, str, Expression, Option<str>];
    type AttrSplat = [Opcodes.AttrSplat, YieldTo];
    type Yield = [Opcodes.Yield, YieldTo, Option<Params>];
    type Partial = [Opcodes.Partial, Expression, Core.EvalInfo];
    type DynamicArg = [Opcodes.DynamicArg, str, Expression];
    type StaticArg = [Opcodes.StaticArg, str, Expression];
    type TrustingAttr = [Opcodes.TrustingAttr, str, Expression, str];
    type Debugger = [Opcodes.Debugger, Core.EvalInfo];
    type ClientSide = [Opcodes.ClientSideStatement, any] | [Opcodes.ClientSideStatement, any, any];
    type Statement = Text | Append | Comment | Modifier | Block | Component | DynamicComponent | OpenElement | SplatElement | FlushElement | CloseElement | StaticAttr | DynamicAttr | AttrSplat | Yield | Partial | StaticArg | DynamicArg | TrustingAttr | Debugger | ClientSide;
    type Attribute = Statements.StaticAttr | Statements.DynamicAttr | Statements.AttrSplat;
    type Argument = Statements.StaticArg | Statements.DynamicArg;
    type Parameter = Attribute | Argument;
}
export declare type Statement = Statements.Statement;
export declare type Attribute = Statements.Attribute;
export declare type Parameter = Statements.Parameter;
/**
 * A JSON object of static compile time meta for the template.
 */
export interface TemplateMeta {
    [key: string]: Opaque;
    moduleName?: string;
}
/**
 * A JSON object that the Block was serialized into.
 */
export interface SerializedBlock {
    statements: Statements.Statement[];
}
export interface SerializedInlineBlock extends SerializedBlock {
    parameters: number[];
}
/**
 * A JSON object that the compiled TemplateBlock was serialized into.
 */
export interface SerializedTemplateBlock extends SerializedBlock {
    symbols: string[];
    hasEval: boolean;
}
/**
 * A JSON object that the compiled Template was serialized into.
 */
export interface SerializedTemplate<T extends TemplateMeta> {
    block: SerializedTemplateBlock;
    meta: T;
}
/**
 * A string of JSON containing a SerializedTemplateBlock
 */
export declare type SerializedTemplateBlockJSON = string;
/**
 * A JSON object containing the SerializedTemplateBlock as JSON and Locator.
 */
export interface SerializedTemplateWithLazyBlock<Locator> {
    id?: Option<string>;
    block: SerializedTemplateBlockJSON;
    meta: Locator;
}
/**
 * A string of Javascript containing a SerializedTemplateWithLazyBlock to be
 * concatenated into a Javascript module.
 */
export declare type TemplateJavascript = string;
export declare const isFlushElement: (value: any) => value is [Opcodes.FlushElement];
export declare const isAttrSplat: (value: any) => value is [Opcodes.AttrSplat, number];
export declare function isAttribute(val: Statement): val is Statements.Attribute;
export declare function isArgument(val: Statement): val is Statements.Argument;
export declare const isGet: (value: any) => value is [Opcodes.Get, number, string[]];
export declare const isMaybeLocal: (value: any) => value is [Opcodes.MaybeLocal, string[]];
