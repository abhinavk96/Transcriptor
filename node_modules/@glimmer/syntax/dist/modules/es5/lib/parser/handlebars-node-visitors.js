function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

import b from '../builders';
import { appendChild, isLiteral, printLiteral } from '../utils';
import { Parser } from '../parser';
import SyntaxError from '../errors/syntax-error';
export var HandlebarsNodeVisitors = function (_Parser) {
    _inherits(HandlebarsNodeVisitors, _Parser);

    function HandlebarsNodeVisitors() {
        _classCallCheck(this, HandlebarsNodeVisitors);

        var _this = _possibleConstructorReturn(this, _Parser.apply(this, arguments));

        _this.cursorCount = 0;
        return _this;
    }

    HandlebarsNodeVisitors.prototype.cursor = function cursor() {
        return '%cursor:' + this.cursorCount++ + '%';
    };

    HandlebarsNodeVisitors.prototype.Program = function Program(program) {
        var body = [];
        this.cursorCount = 0;
        var node = b.program(body, program.blockParams, program.loc);
        var i = void 0,
            l = program.body.length;
        this.elementStack.push(node);
        if (l === 0) {
            return this.elementStack.pop();
        }
        for (i = 0; i < l; i++) {
            this.acceptNode(program.body[i]);
        }
        // Ensure that that the element stack is balanced properly.
        var poppedNode = this.elementStack.pop();
        if (poppedNode !== node) {
            var elementNode = poppedNode;
            throw new SyntaxError('Unclosed element `' + elementNode.tag + '` (on line ' + elementNode.loc.start.line + ').', elementNode.loc);
        }
        return node;
    };

    HandlebarsNodeVisitors.prototype.BlockStatement = function BlockStatement(block) {
        if (this.tokenizer['state'] === 'comment') {
            this.appendToCommentData(this.sourceForNode(block));
            return;
        }
        if (this.tokenizer['state'] !== 'comment' && this.tokenizer['state'] !== 'data' && this.tokenizer['state'] !== 'beforeData') {
            throw new SyntaxError('A block may only be used inside an HTML element or another block.', block.loc);
        }

        var _acceptCallNodes = acceptCallNodes(this, block),
            path = _acceptCallNodes.path,
            params = _acceptCallNodes.params,
            hash = _acceptCallNodes.hash;

        var program = this.Program(block.program);
        var inverse = block.inverse ? this.Program(block.inverse) : null;
        if (path.original === 'in-element') {
            hash = addInElementHash(this.cursor(), hash, block.loc);
        }
        var node = b.block(path, params, hash, program, inverse, block.loc);
        var parentProgram = this.currentElement();
        appendChild(parentProgram, node);
    };

    HandlebarsNodeVisitors.prototype.MustacheStatement = function MustacheStatement(rawMustache) {
        var tokenizer = this.tokenizer;

        if (tokenizer.state === 'comment') {
            this.appendToCommentData(this.sourceForNode(rawMustache));
            return;
        }
        var mustache = void 0;
        var escaped = rawMustache.escaped,
            loc = rawMustache.loc;

        if (rawMustache.path.type.match(/Literal$/)) {
            mustache = {
                type: 'MustacheStatement',
                path: this.acceptNode(rawMustache.path),
                params: [],
                hash: b.hash(),
                escaped: escaped,
                loc: loc
            };
        } else {
            var _acceptCallNodes2 = acceptCallNodes(this, rawMustache),
                path = _acceptCallNodes2.path,
                params = _acceptCallNodes2.params,
                hash = _acceptCallNodes2.hash;

            mustache = b.mustache(path, params, hash, !escaped, loc);
        }
        switch (tokenizer.state) {
            // Tag helpers
            case "tagOpen" /* tagOpen */:
            case "tagName" /* tagName */:
                throw new SyntaxError('Cannot use mustaches in an elements tagname: `' + this.sourceForNode(rawMustache, rawMustache.path) + '` at L' + loc.start.line + ':C' + loc.start.column, mustache.loc);
            case "beforeAttributeName" /* beforeAttributeName */:
                addElementModifier(this.currentStartTag, mustache);
                break;
            case "attributeName" /* attributeName */:
            case "afterAttributeName" /* afterAttributeName */:
                this.beginAttributeValue(false);
                this.finishAttributeValue();
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                break;
            case "afterAttributeValueQuoted" /* afterAttributeValueQuoted */:
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                break;
            // Attribute values
            case "beforeAttributeValue" /* beforeAttributeValue */:
                this.beginAttributeValue(false);
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                tokenizer.transitionTo("attributeValueUnquoted" /* attributeValueUnquoted */);
                break;
            case "attributeValueDoubleQuoted" /* attributeValueDoubleQuoted */:
            case "attributeValueSingleQuoted" /* attributeValueSingleQuoted */:
            case "attributeValueUnquoted" /* attributeValueUnquoted */:
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                break;
            // TODO: Only append child when the tokenizer state makes
            // sense to do so, otherwise throw an error.
            default:
                appendChild(this.currentElement(), mustache);
        }
        return mustache;
    };

    HandlebarsNodeVisitors.prototype.ContentStatement = function ContentStatement(content) {
        updateTokenizerLocation(this.tokenizer, content);
        this.tokenizer.tokenizePart(content.value);
        this.tokenizer.flushData();
    };

    HandlebarsNodeVisitors.prototype.CommentStatement = function CommentStatement(rawComment) {
        var tokenizer = this.tokenizer;

        if (tokenizer.state === "comment" /* comment */) {
                this.appendToCommentData(this.sourceForNode(rawComment));
                return null;
            }
        var value = rawComment.value,
            loc = rawComment.loc;

        var comment = b.mustacheComment(value, loc);
        switch (tokenizer.state) {
            case "beforeAttributeName" /* beforeAttributeName */:
                this.currentStartTag.comments.push(comment);
                break;
            case "beforeData" /* beforeData */:
            case "data" /* data */:
                appendChild(this.currentElement(), comment);
                break;
            default:
                throw new SyntaxError('Using a Handlebars comment when in the `' + tokenizer['state'] + '` state is not supported: "' + comment.value + '" on line ' + loc.start.line + ':' + loc.start.column, rawComment.loc);
        }
        return comment;
    };

    HandlebarsNodeVisitors.prototype.PartialStatement = function PartialStatement(partial) {
        var loc = partial.loc;

        throw new SyntaxError('Handlebars partials are not supported: "' + this.sourceForNode(partial, partial.name) + '" at L' + loc.start.line + ':C' + loc.start.column, partial.loc);
    };

    HandlebarsNodeVisitors.prototype.PartialBlockStatement = function PartialBlockStatement(partialBlock) {
        var loc = partialBlock.loc;

        throw new SyntaxError('Handlebars partial blocks are not supported: "' + this.sourceForNode(partialBlock, partialBlock.name) + '" at L' + loc.start.line + ':C' + loc.start.column, partialBlock.loc);
    };

    HandlebarsNodeVisitors.prototype.Decorator = function Decorator(decorator) {
        var loc = decorator.loc;

        throw new SyntaxError('Handlebars decorators are not supported: "' + this.sourceForNode(decorator, decorator.path) + '" at L' + loc.start.line + ':C' + loc.start.column, decorator.loc);
    };

    HandlebarsNodeVisitors.prototype.DecoratorBlock = function DecoratorBlock(decoratorBlock) {
        var loc = decoratorBlock.loc;

        throw new SyntaxError('Handlebars decorator blocks are not supported: "' + this.sourceForNode(decoratorBlock, decoratorBlock.path) + '" at L' + loc.start.line + ':C' + loc.start.column, decoratorBlock.loc);
    };

    HandlebarsNodeVisitors.prototype.SubExpression = function SubExpression(sexpr) {
        var _acceptCallNodes3 = acceptCallNodes(this, sexpr),
            path = _acceptCallNodes3.path,
            params = _acceptCallNodes3.params,
            hash = _acceptCallNodes3.hash;

        return b.sexpr(path, params, hash, sexpr.loc);
    };

    HandlebarsNodeVisitors.prototype.PathExpression = function PathExpression(path) {
        var original = path.original,
            loc = path.loc;

        var parts = void 0;
        if (original.indexOf('/') !== -1) {
            if (original.slice(0, 2) === './') {
                throw new SyntaxError('Using "./" is not supported in Glimmer and unnecessary: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            if (original.slice(0, 3) === '../') {
                throw new SyntaxError('Changing context using "../" is not supported in Glimmer: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            if (original.indexOf('.') !== -1) {
                throw new SyntaxError('Mixing \'.\' and \'/\' in paths is not supported in Glimmer; use only \'.\' to separate property paths: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            parts = [path.parts.join('/')];
        } else if (original === '.') {
            var locationInfo = 'L' + loc.start.line + ':C' + loc.start.column;
            throw new SyntaxError('\'.\' is not a supported path in Glimmer; check for a path with a trailing \'.\' at ' + locationInfo + '.', path.loc);
        } else {
            parts = path.parts;
        }
        var thisHead = false;
        // This is to fix a bug in the Handlebars AST where the path expressions in
        // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)
        // are simply turned into `{{foo}}`. The fix is to push it back onto the
        // parts array and let the runtime see the difference. However, we cannot
        // simply use the string `this` as it means literally the property called
        // "this" in the current context (it can be expressed in the syntax as
        // `{{[this]}}`, where the square bracket are generally for this kind of
        // escaping â€“ such as `{{foo.["bar.baz"]}}` would mean lookup a property
        // named literally "bar.baz" on `this.foo`). By convention, we use `null`
        // for this purpose.
        if (original.match(/^this(\..+)?$/)) {
            thisHead = true;
        }
        return {
            type: 'PathExpression',
            original: path.original,
            this: thisHead,
            parts: parts,
            data: path.data,
            loc: path.loc
        };
    };

    HandlebarsNodeVisitors.prototype.Hash = function Hash(hash) {
        var pairs = [];
        for (var i = 0; i < hash.pairs.length; i++) {
            var pair = hash.pairs[i];
            pairs.push(b.pair(pair.key, this.acceptNode(pair.value), pair.loc));
        }
        return b.hash(pairs, hash.loc);
    };

    HandlebarsNodeVisitors.prototype.StringLiteral = function StringLiteral(string) {
        return b.literal('StringLiteral', string.value, string.loc);
    };

    HandlebarsNodeVisitors.prototype.BooleanLiteral = function BooleanLiteral(boolean) {
        return b.literal('BooleanLiteral', boolean.value, boolean.loc);
    };

    HandlebarsNodeVisitors.prototype.NumberLiteral = function NumberLiteral(number) {
        return b.literal('NumberLiteral', number.value, number.loc);
    };

    HandlebarsNodeVisitors.prototype.UndefinedLiteral = function UndefinedLiteral(undef) {
        return b.literal('UndefinedLiteral', undefined, undef.loc);
    };

    HandlebarsNodeVisitors.prototype.NullLiteral = function NullLiteral(nul) {
        return b.literal('NullLiteral', null, nul.loc);
    };

    return HandlebarsNodeVisitors;
}(Parser);
function calculateRightStrippedOffsets(original, value) {
    if (value === '') {
        // if it is empty, just return the count of newlines
        // in original
        return {
            lines: original.split('\n').length - 1,
            columns: 0
        };
    }
    // otherwise, return the number of newlines prior to
    // `value`
    var difference = original.split(value)[0];
    var lines = difference.split(/\n/);
    var lineCount = lines.length - 1;
    return {
        lines: lineCount,
        columns: lines[lineCount].length
    };
}
function updateTokenizerLocation(tokenizer, content) {
    var line = content.loc.start.line;
    var column = content.loc.start.column;
    var offsets = calculateRightStrippedOffsets(content.original, content.value);
    line = line + offsets.lines;
    if (offsets.lines) {
        column = offsets.columns;
    } else {
        column = column + offsets.columns;
    }
    tokenizer.line = line;
    tokenizer.column = column;
}
function acceptCallNodes(compiler, node) {
    var path = compiler.PathExpression(node.path);
    var params = node.params ? node.params.map(function (e) {
        return compiler.acceptNode(e);
    }) : [];
    var hash = node.hash ? compiler.Hash(node.hash) : b.hash();
    return { path: path, params: params, hash: hash };
}
function addElementModifier(element, mustache) {
    var path = mustache.path,
        params = mustache.params,
        hash = mustache.hash,
        loc = mustache.loc;

    if (isLiteral(path)) {
        var _modifier = '{{' + printLiteral(path) + '}}';
        var tag = '<' + element.name + ' ... ' + _modifier + ' ...';
        throw new SyntaxError('In ' + tag + ', ' + _modifier + ' is not a valid modifier: "' + path.original + '" on line ' + (loc && loc.start.line) + '.', mustache.loc);
    }
    var modifier = b.elementModifier(path, params, hash, loc);
    element.modifiers.push(modifier);
}
function addInElementHash(cursor, hash, loc) {
    var hasNextSibling = false;
    hash.pairs.forEach(function (pair) {
        if (pair.key === 'guid') {
            throw new SyntaxError('Cannot pass `guid` from user space', loc);
        }
        if (pair.key === 'nextSibling') {
            hasNextSibling = true;
        }
    });
    var guid = b.literal('StringLiteral', cursor);
    var guidPair = b.pair('guid', guid);
    hash.pairs.unshift(guidPair);
    if (!hasNextSibling) {
        var nullLiteral = b.literal('NullLiteral', null);
        var nextSibling = b.pair('nextSibling', nullLiteral);
        hash.pairs.push(nextSibling);
    }
    return hash;
}
function appendDynamicAttributeValuePart(attribute, part) {
    attribute.isDynamic = true;
    attribute.parts.push(part);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFuZGxlYmFycy1ub2RlLXZpc2l0b3JzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvc3ludGF4L2xpYi9wYXJzZXIvaGFuZGxlYmFycy1ub2RlLXZpc2l0b3JzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsT0FBTyxBQUFDLE9BQU0sQUFBYSxBQUFDO0FBQzVCLEFBQU8sU0FBRSxBQUFXLGFBQUUsQUFBUyxXQUFFLEFBQVksQUFBRSxvQkFBTSxBQUFVLEFBQUM7QUFHaEUsQUFBTyxTQUFFLEFBQU0sQUFBa0IsY0FBTSxBQUFXLEFBQUM7QUFDbkQsT0FBTyxBQUFXLGlCQUFNLEFBQXdCLEFBQUM7QUFLakQsQUFBTSxXQUFnQixBQUF1Qjs7Ozs7O3lFQUszQzs7Y0FBVyxjQUFHLEFBQUMsQUFBQyxBQWtWbEIsQUFBQzs7QUFoVkMsQUFBTTs7Z0VBQ0osQUFBTzs0QkFBVyxBQUFJLEtBQUMsQUFBVyxBQUFFLEFBQUcsQUFBQyxBQUMxQyxBQUFDO0FBRUQsQUFBTzs7Z0VBQUMsQUFBOEIsU0FDcEM7WUFBSSxBQUFJLE9BQW9CLEFBQUUsQUFBQyxBQUMvQixBQUFJO2FBQUMsQUFBVyxjQUFHLEFBQUMsQUFBQyxBQUNyQjtZQUFJLEFBQUksT0FBRyxBQUFDLEVBQUMsQUFBTyxRQUFDLEFBQUksTUFBRSxBQUFPLFFBQUMsQUFBVyxhQUFFLEFBQU8sUUFBQyxBQUFHLEFBQUMsQUFBQyxBQUM3RDtZQUFJLEFBQUM7WUFDSCxBQUFDLElBQUcsQUFBTyxRQUFDLEFBQUksS0FBQyxBQUFNLEFBQUMsQUFFMUIsQUFBSTthQUFDLEFBQVksYUFBQyxBQUFJLEtBQUMsQUFBSSxBQUFDLEFBQUMsQUFFN0I7WUFBSSxBQUFDLE1BQUssQUFBQyxHQUFFLEFBQ1g7bUJBQU8sQUFBSSxLQUFDLEFBQVksYUFBQyxBQUFHLEFBQWlCLEFBQUMsQUFDL0M7QUFFRDthQUFLLEFBQUMsSUFBRyxB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cyc7XG5pbXBvcnQgeyBhcHBlbmRDaGlsZCwgaXNMaXRlcmFsLCBwcmludExpdGVyYWwgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgKiBhcyBBU1QgZnJvbSAnLi4vdHlwZXMvbm9kZXMnO1xuaW1wb3J0ICogYXMgSGFuZGxlYmFyc0FTVCBmcm9tICcuLi90eXBlcy9oYW5kbGViYXJzLWFzdCc7XG5pbXBvcnQgeyBQYXJzZXIsIFRhZywgQXR0cmlidXRlIH0gZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCBTeW50YXhFcnJvciBmcm9tICcuLi9lcnJvcnMvc3ludGF4LWVycm9yJztcbmltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgUmVjYXN0IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBUb2tlbml6ZXJTdGF0ZSB9IGZyb20gJ3NpbXBsZS1odG1sLXRva2VuaXplcic7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBIYW5kbGViYXJzTm9kZVZpc2l0b3JzIGV4dGVuZHMgUGFyc2VyIHtcbiAgYWJzdHJhY3QgYXBwZW5kVG9Db21tZW50RGF0YShzOiBzdHJpbmcpOiB2b2lkO1xuICBhYnN0cmFjdCBiZWdpbkF0dHJpYnV0ZVZhbHVlKHF1b3RlZDogYm9vbGVhbik6IHZvaWQ7XG4gIGFic3RyYWN0IGZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk6IHZvaWQ7XG5cbiAgY3Vyc29yQ291bnQgPSAwO1xuXG4gIGN1cnNvcigpIHtcbiAgICByZXR1cm4gYCVjdXJzb3I6JHt0aGlzLmN1cnNvckNvdW50Kyt9JWA7XG4gIH1cblxuICBQcm9ncmFtKHByb2dyYW06IEhhbmRsZWJhcnNBU1QuUHJvZ3JhbSk6IEFTVC5Qcm9ncmFtIHtcbiAgICBsZXQgYm9keTogQVNULlN0YXRlbWVudFtdID0gW107XG4gICAgdGhpcy5jdXJzb3JDb3VudCA9IDA7XG4gICAgbGV0IG5vZGUgPSBiLnByb2dyYW0oYm9keSwgcHJvZ3JhbS5ibG9ja1BhcmFtcywgcHJvZ3JhbS5sb2MpO1xuICAgIGxldCBpLFxuICAgICAgbCA9IHByb2dyYW0uYm9keS5sZW5ndGg7XG5cbiAgICB0aGlzLmVsZW1lbnRTdGFjay5wdXNoKG5vZGUpO1xuXG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGFjay5wb3AoKSBhcyBBU1QuUHJvZ3JhbTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLmFjY2VwdE5vZGUocHJvZ3JhbS5ib2R5W2ldKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGF0IHRoZSBlbGVtZW50IHN0YWNrIGlzIGJhbGFuY2VkIHByb3Blcmx5LlxuICAgIGxldCBwb3BwZWROb2RlID0gdGhpcy5lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgaWYgKHBvcHBlZE5vZGUgIT09IG5vZGUpIHtcbiAgICAgIGxldCBlbGVtZW50Tm9kZSA9IHBvcHBlZE5vZGUgYXMgQVNULkVsZW1lbnROb2RlO1xuXG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICdVbmNsb3NlZCBlbGVtZW50IGAnICsgZWxlbWVudE5vZGUudGFnICsgJ2AgKG9uIGxpbmUgJyArIGVsZW1lbnROb2RlLmxvYyEuc3RhcnQubGluZSArICcpLicsXG4gICAgICAgIGVsZW1lbnROb2RlLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIEJsb2NrU3RhdGVtZW50KGJsb2NrOiBIYW5kbGViYXJzQVNULkJsb2NrU3RhdGVtZW50KSB7XG4gICAgaWYgKHRoaXMudG9rZW5pemVyWydzdGF0ZSddID09PSAnY29tbWVudCcpIHtcbiAgICAgIHRoaXMuYXBwZW5kVG9Db21tZW50RGF0YSh0aGlzLnNvdXJjZUZvck5vZGUoYmxvY2spKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnRva2VuaXplclsnc3RhdGUnXSAhPT0gJ2NvbW1lbnQnICYmXG4gICAgICB0aGlzLnRva2VuaXplclsnc3RhdGUnXSAhPT0gJ2RhdGEnICYmXG4gICAgICB0aGlzLnRva2VuaXplclsnc3RhdGUnXSAhPT0gJ2JlZm9yZURhdGEnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICdBIGJsb2NrIG1heSBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIEhUTUwgZWxlbWVudCBvciBhbm90aGVyIGJsb2NrLicsXG4gICAgICAgIGJsb2NrLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2Rlcyh0aGlzLCBibG9jayk7XG4gICAgbGV0IHByb2dyYW0gPSB0aGlzLlByb2dyYW0oYmxvY2sucHJvZ3JhbSk7XG4gICAgbGV0IGludmVyc2UgPSBibG9jay5pbnZlcnNlID8gdGhpcy5Qcm9ncmFtKGJsb2NrLmludmVyc2UpIDogbnVsbDtcblxuICAgIGlmIChwYXRoLm9yaWdpbmFsID09PSAnaW4tZWxlbWVudCcpIHtcbiAgICAgIGhhc2ggPSBhZGRJbkVsZW1lbnRIYXNoKHRoaXMuY3Vyc29yKCksIGhhc2gsIGJsb2NrLmxvYyk7XG4gICAgfVxuXG4gICAgbGV0IG5vZGUgPSBiLmJsb2NrKHBhdGgsIHBhcmFtcywgaGFzaCwgcHJvZ3JhbSwgaW52ZXJzZSwgYmxvY2subG9jKTtcblxuICAgIGxldCBwYXJlbnRQcm9ncmFtID0gdGhpcy5jdXJyZW50RWxlbWVudCgpO1xuICAgIGFwcGVuZENoaWxkKHBhcmVudFByb2dyYW0sIG5vZGUpO1xuICB9XG5cbiAgTXVzdGFjaGVTdGF0ZW1lbnQocmF3TXVzdGFjaGU6IEhhbmRsZWJhcnNBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgICBsZXQgeyB0b2tlbml6ZXIgfSA9IHRoaXM7XG5cbiAgICBpZiAodG9rZW5pemVyLnN0YXRlID09PSAnY29tbWVudCcpIHtcbiAgICAgIHRoaXMuYXBwZW5kVG9Db21tZW50RGF0YSh0aGlzLnNvdXJjZUZvck5vZGUocmF3TXVzdGFjaGUpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbXVzdGFjaGU6IEFTVC5NdXN0YWNoZVN0YXRlbWVudDtcbiAgICBsZXQgeyBlc2NhcGVkLCBsb2MgfSA9IHJhd011c3RhY2hlO1xuXG4gICAgaWYgKHJhd011c3RhY2hlLnBhdGgudHlwZS5tYXRjaCgvTGl0ZXJhbCQvKSkge1xuICAgICAgbXVzdGFjaGUgPSB7XG4gICAgICAgIHR5cGU6ICdNdXN0YWNoZVN0YXRlbWVudCcsXG4gICAgICAgIHBhdGg6IHRoaXMuYWNjZXB0Tm9kZTxBU1QuTGl0ZXJhbD4ocmF3TXVzdGFjaGUucGF0aCksXG4gICAgICAgIHBhcmFtczogW10sXG4gICAgICAgIGhhc2g6IGIuaGFzaCgpLFxuICAgICAgICBlc2NhcGVkLFxuICAgICAgICBsb2MsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2RlcyhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgcmF3TXVzdGFjaGUgYXMgSGFuZGxlYmFyc0FTVC5NdXN0YWNoZVN0YXRlbWVudCAmIHtcbiAgICAgICAgICBwYXRoOiBIYW5kbGViYXJzQVNULlBhdGhFeHByZXNzaW9uO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgbXVzdGFjaGUgPSBiLm11c3RhY2hlKHBhdGgsIHBhcmFtcywgaGFzaCwgIWVzY2FwZWQsIGxvYyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b2tlbml6ZXIuc3RhdGUpIHtcbiAgICAgIC8vIFRhZyBoZWxwZXJzXG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLnRhZ09wZW46XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLnRhZ05hbWU6XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICBgQ2Fubm90IHVzZSBtdXN0YWNoZXMgaW4gYW4gZWxlbWVudHMgdGFnbmFtZTogXFxgJHt0aGlzLnNvdXJjZUZvck5vZGUoXG4gICAgICAgICAgICByYXdNdXN0YWNoZSxcbiAgICAgICAgICAgIHJhd011c3RhY2hlLnBhdGhcbiAgICAgICAgICApfVxcYCBhdCBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLFxuICAgICAgICAgIG11c3RhY2hlLmxvY1xuICAgICAgICApO1xuXG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWU6XG4gICAgICAgIGFkZEVsZW1lbnRNb2RpZmllcih0aGlzLmN1cnJlbnRTdGFydFRhZywgbXVzdGFjaGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlTmFtZTpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYWZ0ZXJBdHRyaWJ1dGVOYW1lOlxuICAgICAgICB0aGlzLmJlZ2luQXR0cmlidXRlVmFsdWUoZmFsc2UpO1xuICAgICAgICB0aGlzLmZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgIGFkZEVsZW1lbnRNb2RpZmllcih0aGlzLmN1cnJlbnRTdGFydFRhZywgbXVzdGFjaGUpO1xuICAgICAgICB0b2tlbml6ZXIudHJhbnNpdGlvblRvKFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYWZ0ZXJBdHRyaWJ1dGVWYWx1ZVF1b3RlZDpcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIHRva2VuaXplci50cmFuc2l0aW9uVG8oVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBBdHRyaWJ1dGUgdmFsdWVzXG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZVZhbHVlOlxuICAgICAgICB0aGlzLmJlZ2luQXR0cmlidXRlVmFsdWUoZmFsc2UpO1xuICAgICAgICBhcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KHRoaXMuY3VycmVudEF0dHJpYnV0ZSEsIG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyLnRyYW5zaXRpb25UbyhUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZVVucXVvdGVkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVkOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZVNpbmdsZVF1b3RlZDpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlVmFsdWVVbnF1b3RlZDpcbiAgICAgICAgYXBwZW5kRHluYW1pY0F0dHJpYnV0ZVZhbHVlUGFydCh0aGlzLmN1cnJlbnRBdHRyaWJ1dGUhLCBtdXN0YWNoZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBUT0RPOiBPbmx5IGFwcGVuZCBjaGlsZCB3aGVuIHRoZSB0b2tlbml6ZXIgc3RhdGUgbWFrZXNcbiAgICAgIC8vIHNlbnNlIHRvIGRvIHNvLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRFbGVtZW50KCksIG11c3RhY2hlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbXVzdGFjaGU7XG4gIH1cblxuICBDb250ZW50U3RhdGVtZW50KGNvbnRlbnQ6IEhhbmRsZWJhcnNBU1QuQ29udGVudFN0YXRlbWVudCkge1xuICAgIHVwZGF0ZVRva2VuaXplckxvY2F0aW9uKHRoaXMudG9rZW5pemVyLCBjb250ZW50KTtcblxuICAgIHRoaXMudG9rZW5pemVyLnRva2VuaXplUGFydChjb250ZW50LnZhbHVlKTtcbiAgICB0aGlzLnRva2VuaXplci5mbHVzaERhdGEoKTtcbiAgfVxuXG4gIENvbW1lbnRTdGF0ZW1lbnQoXG4gICAgcmF3Q29tbWVudDogSGFuZGxlYmFyc0FTVC5Db21tZW50U3RhdGVtZW50XG4gICk6IE9wdGlvbjxBU1QuTXVzdGFjaGVDb21tZW50U3RhdGVtZW50PiB7XG4gICAgbGV0IHsgdG9rZW5pemVyIH0gPSB0aGlzO1xuXG4gICAgaWYgKHRva2VuaXplci5zdGF0ZSA9PT0gVG9rZW5pemVyU3RhdGUuY29tbWVudCkge1xuICAgICAgdGhpcy5hcHBlbmRUb0NvbW1lbnREYXRhKHRoaXMuc291cmNlRm9yTm9kZShyYXdDb21tZW50KSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgeyB2YWx1ZSwgbG9jIH0gPSByYXdDb21tZW50O1xuICAgIGxldCBjb21tZW50ID0gYi5tdXN0YWNoZUNvbW1lbnQodmFsdWUsIGxvYyk7XG5cbiAgICBzd2l0Y2ggKHRva2VuaXplci5zdGF0ZSkge1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lOlxuICAgICAgICB0aGlzLmN1cnJlbnRTdGFydFRhZy5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVEYXRhOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5kYXRhOlxuICAgICAgICBhcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRFbGVtZW50KCksIGNvbW1lbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBVc2luZyBhIEhhbmRsZWJhcnMgY29tbWVudCB3aGVuIGluIHRoZSBcXGAke1xuICAgICAgICAgICAgdG9rZW5pemVyWydzdGF0ZSddXG4gICAgICAgICAgfVxcYCBzdGF0ZSBpcyBub3Qgc3VwcG9ydGVkOiBcIiR7Y29tbWVudC52YWx1ZX1cIiBvbiBsaW5lICR7bG9jLnN0YXJ0LmxpbmV9OiR7XG4gICAgICAgICAgICBsb2Muc3RhcnQuY29sdW1uXG4gICAgICAgICAgfWAsXG4gICAgICAgICAgcmF3Q29tbWVudC5sb2NcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tbWVudDtcbiAgfVxuXG4gIFBhcnRpYWxTdGF0ZW1lbnQocGFydGlhbDogSGFuZGxlYmFyc0FTVC5QYXJ0aWFsU3RhdGVtZW50KSB7XG4gICAgbGV0IHsgbG9jIH0gPSBwYXJ0aWFsO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgcGFydGlhbHMgYXJlIG5vdCBzdXBwb3J0ZWQ6IFwiJHt0aGlzLnNvdXJjZUZvck5vZGUocGFydGlhbCwgcGFydGlhbC5uYW1lKX1cIiBhdCBMJHtcbiAgICAgICAgbG9jLnN0YXJ0LmxpbmVcbiAgICAgIH06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLFxuICAgICAgcGFydGlhbC5sb2NcbiAgICApO1xuICB9XG5cbiAgUGFydGlhbEJsb2NrU3RhdGVtZW50KHBhcnRpYWxCbG9jazogSGFuZGxlYmFyc0FTVC5QYXJ0aWFsQmxvY2tTdGF0ZW1lbnQpIHtcbiAgICBsZXQgeyBsb2MgfSA9IHBhcnRpYWxCbG9jaztcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGBIYW5kbGViYXJzIHBhcnRpYWwgYmxvY2tzIGFyZSBub3Qgc3VwcG9ydGVkOiBcIiR7dGhpcy5zb3VyY2VGb3JOb2RlKFxuICAgICAgICBwYXJ0aWFsQmxvY2ssXG4gICAgICAgIHBhcnRpYWxCbG9jay5uYW1lXG4gICAgICApfVwiIGF0IEwke2xvYy5zdGFydC5saW5lfTpDJHtsb2Muc3RhcnQuY29sdW1ufWAsXG4gICAgICBwYXJ0aWFsQmxvY2subG9jXG4gICAgKTtcbiAgfVxuXG4gIERlY29yYXRvcihkZWNvcmF0b3I6IEhhbmRsZWJhcnNBU1QuRGVjb3JhdG9yKSB7XG4gICAgbGV0IHsgbG9jIH0gPSBkZWNvcmF0b3I7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBkZWNvcmF0b3JzIGFyZSBub3Qgc3VwcG9ydGVkOiBcIiR7dGhpcy5zb3VyY2VGb3JOb2RlKFxuICAgICAgICBkZWNvcmF0b3IsXG4gICAgICAgIGRlY29yYXRvci5wYXRoXG4gICAgICApfVwiIGF0IEwke2xvYy5zdGFydC5saW5lfTpDJHtsb2Muc3RhcnQuY29sdW1ufWAsXG4gICAgICBkZWNvcmF0b3IubG9jXG4gICAgKTtcbiAgfVxuXG4gIERlY29yYXRvckJsb2NrKGRlY29yYXRvckJsb2NrOiBIYW5kbGViYXJzQVNULkRlY29yYXRvckJsb2NrKSB7XG4gICAgbGV0IHsgbG9jIH0gPSBkZWNvcmF0b3JCbG9jaztcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGBIYW5kbGViYXJzIGRlY29yYXRvciBibG9ja3MgYXJlIG5vdCBzdXBwb3J0ZWQ6IFwiJHt0aGlzLnNvdXJjZUZvck5vZGUoXG4gICAgICAgIGRlY29yYXRvckJsb2NrLFxuICAgICAgICBkZWNvcmF0b3JCbG9jay5wYXRoXG4gICAgICApfVwiIGF0IEwke2xvYy5zdGFydC5saW5lfTpDJHtsb2Muc3RhcnQuY29sdW1ufWAsXG4gICAgICBkZWNvcmF0b3JCbG9jay5sb2NcbiAgICApO1xuICB9XG5cbiAgU3ViRXhwcmVzc2lvbihzZXhwcjogSGFuZGxlYmFyc0FTVC5TdWJFeHByZXNzaW9uKTogQVNULlN1YkV4cHJlc3Npb24ge1xuICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKHRoaXMsIHNleHByKTtcbiAgICByZXR1cm4gYi5zZXhwcihwYXRoLCBwYXJhbXMsIGhhc2gsIHNleHByLmxvYyk7XG4gIH1cblxuICBQYXRoRXhwcmVzc2lvbihwYXRoOiBIYW5kbGViYXJzQVNULlBhdGhFeHByZXNzaW9uKTogQVNULlBhdGhFeHByZXNzaW9uIHtcbiAgICBsZXQgeyBvcmlnaW5hbCwgbG9jIH0gPSBwYXRoO1xuICAgIGxldCBwYXJ0czogc3RyaW5nW107XG5cbiAgICBpZiAob3JpZ2luYWwuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgaWYgKG9yaWdpbmFsLnNsaWNlKDAsIDIpID09PSAnLi8nKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICBgVXNpbmcgXCIuL1wiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2xpbW1lciBhbmQgdW5uZWNlc3Nhcnk6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtcbiAgICAgICAgICAgIGxvYy5zdGFydC5saW5lXG4gICAgICAgICAgfS5gLFxuICAgICAgICAgIHBhdGgubG9jXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWwuc2xpY2UoMCwgMykgPT09ICcuLi8nKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICBgQ2hhbmdpbmcgY29udGV4dCB1c2luZyBcIi4uL1wiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2xpbW1lcjogXCIke3BhdGgub3JpZ2luYWx9XCIgb24gbGluZSAke1xuICAgICAgICAgICAgbG9jLnN0YXJ0LmxpbmVcbiAgICAgICAgICB9LmAsXG4gICAgICAgICAgcGF0aC5sb2NcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmlnaW5hbC5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICBgTWl4aW5nICcuJyBhbmQgJy8nIGluIHBhdGhzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2xpbW1lcjsgdXNlIG9ubHkgJy4nIHRvIHNlcGFyYXRlIHByb3BlcnR5IHBhdGhzOiBcIiR7XG4gICAgICAgICAgICBwYXRoLm9yaWdpbmFsXG4gICAgICAgICAgfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0uYCxcbiAgICAgICAgICBwYXRoLmxvY1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcGFydHMgPSBbcGF0aC5wYXJ0cy5qb2luKCcvJyldO1xuICAgIH0gZWxzZSBpZiAob3JpZ2luYWwgPT09ICcuJykge1xuICAgICAgbGV0IGxvY2F0aW9uSW5mbyA9IGBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gO1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICBgJy4nIGlzIG5vdCBhIHN1cHBvcnRlZCBwYXRoIGluIEdsaW1tZXI7IGNoZWNrIGZvciBhIHBhdGggd2l0aCBhIHRyYWlsaW5nICcuJyBhdCAke2xvY2F0aW9uSW5mb30uYCxcbiAgICAgICAgcGF0aC5sb2NcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzID0gcGF0aC5wYXJ0cztcbiAgICB9XG5cbiAgICBsZXQgdGhpc0hlYWQgPSBmYWxzZTtcblxuICAgIC8vIFRoaXMgaXMgdG8gZml4IGEgYnVnIGluIHRoZSBIYW5kbGViYXJzIEFTVCB3aGVyZSB0aGUgcGF0aCBleHByZXNzaW9ucyBpblxuICAgIC8vIGB7e3RoaXMuZm9vfX1gIChhbmQgc2ltaWxhcmx5IGB7e2Zvby1iYXIgdGhpcy5mb28gbmFtZWQ9dGhpcy5mb299fWAgZXRjKVxuICAgIC8vIGFyZSBzaW1wbHkgdHVybmVkIGludG8gYHt7Zm9vfX1gLiBUaGUgZml4IGlzIHRvIHB1c2ggaXQgYmFjayBvbnRvIHRoZVxuICAgIC8vIHBhcnRzIGFycmF5IGFuZCBsZXQgdGhlIHJ1bnRpbWUgc2VlIHRoZSBkaWZmZXJlbmNlLiBIb3dldmVyLCB3ZSBjYW5ub3RcbiAgICAvLyBzaW1wbHkgdXNlIHRoZSBzdHJpbmcgYHRoaXNgIGFzIGl0IG1lYW5zIGxpdGVyYWxseSB0aGUgcHJvcGVydHkgY2FsbGVkXG4gICAgLy8gXCJ0aGlzXCIgaW4gdGhlIGN1cnJlbnQgY29udGV4dCAoaXQgY2FuIGJlIGV4cHJlc3NlZCBpbiB0aGUgc3ludGF4IGFzXG4gICAgLy8gYHt7W3RoaXNdfX1gLCB3aGVyZSB0aGUgc3F1YXJlIGJyYWNrZXQgYXJlIGdlbmVyYWxseSBmb3IgdGhpcyBraW5kIG9mXG4gICAgLy8gZXNjYXBpbmcg4oCTIHN1Y2ggYXMgYHt7Zm9vLltcImJhci5iYXpcIl19fWAgd291bGQgbWVhbiBsb29rdXAgYSBwcm9wZXJ0eVxuICAgIC8vIG5hbWVkIGxpdGVyYWxseSBcImJhci5iYXpcIiBvbiBgdGhpcy5mb29gKS4gQnkgY29udmVudGlvbiwgd2UgdXNlIGBudWxsYFxuICAgIC8vIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgaWYgKG9yaWdpbmFsLm1hdGNoKC9edGhpcyhcXC4uKyk/JC8pKSB7XG4gICAgICB0aGlzSGVhZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdQYXRoRXhwcmVzc2lvbicsXG4gICAgICBvcmlnaW5hbDogcGF0aC5vcmlnaW5hbCxcbiAgICAgIHRoaXM6IHRoaXNIZWFkLFxuICAgICAgcGFydHMsXG4gICAgICBkYXRhOiBwYXRoLmRhdGEsXG4gICAgICBsb2M6IHBhdGgubG9jLFxuICAgIH07XG4gIH1cblxuICBIYXNoKGhhc2g6IEhhbmRsZWJhcnNBU1QuSGFzaCk6IEFTVC5IYXNoIHtcbiAgICBsZXQgcGFpcnM6IEFTVC5IYXNoUGFpcltdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhhc2gucGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBwYWlyID0gaGFzaC5wYWlyc1tpXTtcbiAgICAgIHBhaXJzLnB1c2goYi5wYWlyKHBhaXIua2V5LCB0aGlzLmFjY2VwdE5vZGU8QVNULkV4cHJlc3Npb24+KHBhaXIudmFsdWUpLCBwYWlyLmxvYykpO1xuICAgIH1cblxuICAgIHJldHVybiBiLmhhc2gocGFpcnMsIGhhc2gubG9jKTtcbiAgfVxuXG4gIFN0cmluZ0xpdGVyYWwoc3RyaW5nOiBIYW5kbGViYXJzQVNULlN0cmluZ0xpdGVyYWwpIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKCdTdHJpbmdMaXRlcmFsJywgc3RyaW5nLnZhbHVlLCBzdHJpbmcubG9jKTtcbiAgfVxuXG4gIEJvb2xlYW5MaXRlcmFsKGJvb2xlYW46IEhhbmRsZWJhcnNBU1QuQm9vbGVhbkxpdGVyYWwpIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKCdCb29sZWFuTGl0ZXJhbCcsIGJvb2xlYW4udmFsdWUsIGJvb2xlYW4ubG9jKTtcbiAgfVxuXG4gIE51bWJlckxpdGVyYWwobnVtYmVyOiBIYW5kbGViYXJzQVNULk51bWJlckxpdGVyYWwpIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKCdOdW1iZXJMaXRlcmFsJywgbnVtYmVyLnZhbHVlLCBudW1iZXIubG9jKTtcbiAgfVxuXG4gIFVuZGVmaW5lZExpdGVyYWwodW5kZWY6IEhhbmRsZWJhcnNBU1QuVW5kZWZpbmVkTGl0ZXJhbCkge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ1VuZGVmaW5lZExpdGVyYWwnLCB1bmRlZmluZWQsIHVuZGVmLmxvYyk7XG4gIH1cblxuICBOdWxsTGl0ZXJhbChudWw6IEhhbmRsZWJhcnNBU1QuTnVsbExpdGVyYWwpIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKCdOdWxsTGl0ZXJhbCcsIG51bGwsIG51bC5sb2MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJpZ2h0U3RyaXBwZWRPZmZzZXRzKG9yaWdpbmFsOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlID09PSAnJykge1xuICAgIC8vIGlmIGl0IGlzIGVtcHR5LCBqdXN0IHJldHVybiB0aGUgY291bnQgb2YgbmV3bGluZXNcbiAgICAvLyBpbiBvcmlnaW5hbFxuICAgIHJldHVybiB7XG4gICAgICBsaW5lczogb3JpZ2luYWwuc3BsaXQoJ1xcbicpLmxlbmd0aCAtIDEsXG4gICAgICBjb2x1bW5zOiAwLFxuICAgIH07XG4gIH1cblxuICAvLyBvdGhlcndpc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIG5ld2xpbmVzIHByaW9yIHRvXG4gIC8vIGB2YWx1ZWBcbiAgbGV0IGRpZmZlcmVuY2UgPSBvcmlnaW5hbC5zcGxpdCh2YWx1ZSlbMF07XG4gIGxldCBsaW5lcyA9IGRpZmZlcmVuY2Uuc3BsaXQoL1xcbi8pO1xuICBsZXQgbGluZUNvdW50ID0gbGluZXMubGVuZ3RoIC0gMTtcblxuICByZXR1cm4ge1xuICAgIGxpbmVzOiBsaW5lQ291bnQsXG4gICAgY29sdW1uczogbGluZXNbbGluZUNvdW50XS5sZW5ndGgsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRva2VuaXplckxvY2F0aW9uKFxuICB0b2tlbml6ZXI6IFBhcnNlclsndG9rZW5pemVyJ10sXG4gIGNvbnRlbnQ6IEhhbmRsZWJhcnNBU1QuQ29udGVudFN0YXRlbWVudFxuKSB7XG4gIGxldCBsaW5lID0gY29udGVudC5sb2Muc3RhcnQubGluZTtcbiAgbGV0IGNvbHVtbiA9IGNvbnRlbnQubG9jLnN0YXJ0LmNvbHVtbjtcblxuICBsZXQgb2Zmc2V0cyA9IGNhbGN1bGF0ZVJpZ2h0U3RyaXBwZWRPZmZzZXRzKFxuICAgIGNvbnRlbnQub3JpZ2luYWwgYXMgUmVjYXN0PEhhbmRsZWJhcnNBU1QuU3RyaXBGbGFncywgc3RyaW5nPixcbiAgICBjb250ZW50LnZhbHVlXG4gICk7XG5cbiAgbGluZSA9IGxpbmUgKyBvZmZzZXRzLmxpbmVzO1xuICBpZiAob2Zmc2V0cy5saW5lcykge1xuICAgIGNvbHVtbiA9IG9mZnNldHMuY29sdW1ucztcbiAgfSBlbHNlIHtcbiAgICBjb2x1bW4gPSBjb2x1bW4gKyBvZmZzZXRzLmNvbHVtbnM7XG4gIH1cblxuICB0b2tlbml6ZXIubGluZSA9IGxpbmU7XG4gIHRva2VuaXplci5jb2x1bW4gPSBjb2x1bW47XG59XG5cbmZ1bmN0aW9uIGFjY2VwdENhbGxOb2RlcyhcbiAgY29tcGlsZXI6IEhhbmRsZWJhcnNOb2RlVmlzaXRvcnMsXG4gIG5vZGU6IHtcbiAgICBwYXRoOiBIYW5kbGViYXJzQVNULlBhdGhFeHByZXNzaW9uO1xuICAgIHBhcmFtczogSGFuZGxlYmFyc0FTVC5FeHByZXNzaW9uW107XG4gICAgaGFzaDogSGFuZGxlYmFyc0FTVC5IYXNoO1xuICB9XG4pOiB7IHBhdGg6IEFTVC5QYXRoRXhwcmVzc2lvbjsgcGFyYW1zOiBBU1QuRXhwcmVzc2lvbltdOyBoYXNoOiBBU1QuSGFzaCB9IHtcbiAgbGV0IHBhdGggPSBjb21waWxlci5QYXRoRXhwcmVzc2lvbihub2RlLnBhdGgpO1xuXG4gIGxldCBwYXJhbXMgPSBub2RlLnBhcmFtcyA/IG5vZGUucGFyYW1zLm1hcChlID0+IGNvbXBpbGVyLmFjY2VwdE5vZGU8QVNULkV4cHJlc3Npb24+KGUpKSA6IFtdO1xuICBsZXQgaGFzaCA9IG5vZGUuaGFzaCA/IGNvbXBpbGVyLkhhc2gobm9kZS5oYXNoKSA6IGIuaGFzaCgpO1xuXG4gIHJldHVybiB7IHBhdGgsIHBhcmFtcywgaGFzaCB9O1xufVxuXG5mdW5jdGlvbiBhZGRFbGVtZW50TW9kaWZpZXIoZWxlbWVudDogVGFnPCdTdGFydFRhZyc+LCBtdXN0YWNoZTogQVNULk11c3RhY2hlU3RhdGVtZW50KSB7XG4gIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCwgbG9jIH0gPSBtdXN0YWNoZTtcblxuICBpZiAoaXNMaXRlcmFsKHBhdGgpKSB7XG4gICAgbGV0IG1vZGlmaWVyID0gYHt7JHtwcmludExpdGVyYWwocGF0aCl9fX1gO1xuICAgIGxldCB0YWcgPSBgPCR7ZWxlbWVudC5uYW1lfSAuLi4gJHttb2RpZmllcn0gLi4uYDtcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGBJbiAke3RhZ30sICR7bW9kaWZpZXJ9IGlzIG5vdCBhIHZhbGlkIG1vZGlmaWVyOiBcIiR7cGF0aC5vcmlnaW5hbH1cIiBvbiBsaW5lICR7bG9jICYmXG4gICAgICAgIGxvYy5zdGFydC5saW5lfS5gLFxuICAgICAgbXVzdGFjaGUubG9jXG4gICAgKTtcbiAgfVxuXG4gIGxldCBtb2RpZmllciA9IGIuZWxlbWVudE1vZGlmaWVyKHBhdGgsIHBhcmFtcywgaGFzaCwgbG9jKTtcbiAgZWxlbWVudC5tb2RpZmllcnMucHVzaChtb2RpZmllcik7XG59XG5cbmZ1bmN0aW9uIGFkZEluRWxlbWVudEhhc2goY3Vyc29yOiBzdHJpbmcsIGhhc2g6IEFTVC5IYXNoLCBsb2M6IEFTVC5Tb3VyY2VMb2NhdGlvbikge1xuICBsZXQgaGFzTmV4dFNpYmxpbmcgPSBmYWxzZTtcbiAgaGFzaC5wYWlycy5mb3JFYWNoKHBhaXIgPT4ge1xuICAgIGlmIChwYWlyLmtleSA9PT0gJ2d1aWQnKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0Nhbm5vdCBwYXNzIGBndWlkYCBmcm9tIHVzZXIgc3BhY2UnLCBsb2MpO1xuICAgIH1cblxuICAgIGlmIChwYWlyLmtleSA9PT0gJ25leHRTaWJsaW5nJykge1xuICAgICAgaGFzTmV4dFNpYmxpbmcgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGd1aWQgPSBiLmxpdGVyYWwoJ1N0cmluZ0xpdGVyYWwnLCBjdXJzb3IpO1xuICBsZXQgZ3VpZFBhaXIgPSBiLnBhaXIoJ2d1aWQnLCBndWlkKTtcbiAgaGFzaC5wYWlycy51bnNoaWZ0KGd1aWRQYWlyKTtcblxuICBpZiAoIWhhc05leHRTaWJsaW5nKSB7XG4gICAgbGV0IG51bGxMaXRlcmFsID0gYi5saXRlcmFsKCdOdWxsTGl0ZXJhbCcsIG51bGwpO1xuICAgIGxldCBuZXh0U2libGluZyA9IGIucGFpcignbmV4dFNpYmxpbmcnLCBudWxsTGl0ZXJhbCk7XG4gICAgaGFzaC5wYWlycy5wdXNoKG5leHRTaWJsaW5nKTtcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufVxuXG5mdW5jdGlvbiBhcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KGF0dHJpYnV0ZTogQXR0cmlidXRlLCBwYXJ0OiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgYXR0cmlidXRlLmlzRHluYW1pYyA9IHRydWU7XG4gIGF0dHJpYnV0ZS5wYXJ0cy5wdXNoKHBhcnQpO1xufVxuIl19